# Using Infrastructure as Code tools to define ownership and responsibility - Transcript

DAWN: I'm guessing that you can all hear me?

ROB: I can!

DAWN: Excellent!  I regret to inform you that despite my constant protestations to the universe, I have not yet managed to grow a third hand.

ROB: [laughs]

DAWN: Let me just start everything up - I just need to give it - Now, if we plug this in, one hopes that at some stage it will - 

ROB: Fingers crossed.

DAWN: - magically work.  Although, considering the earlier technical difficulties, that may be opti... mistic!  There we go.

ROB: Yay!

DAWN: All right.  [pause]  Well.  Ah, for the second time - actually, for the third time in three months, because I believe I did What's New in AWS last month - erm, I am here again at the  Melbourne AWS User Group and it is lovely to be here.  Today I'm going off my, sort of, standard beaten path of the governance, risk, and compliance services, ah, and other things along those lines that I generally come to rant to you about.  And we are going to talk about using infrastructure as code tools to define ownership and responsibility across your organisation.

To begin with, I would like to acknowledge the Wundj - the Wurundjeri people of the Kulin Nation - it would help, apologies to them, if I could actually pronounce that name properly - on whose land I am presenting tonight.  This is, and always will be, Aboriginal land.  Their sovereignty was never ceded.

I'm hoping that considering that this is my third time here in three months, most of the audience knows who I am.  But, for those of you who have not met me before; my name is Dawn; I do cloud security and DevOps type work at Innablr - and we are hiring, so I'm sure you'll be hearing from me again in the marketplace segment; erm, what probably pretty much no one here knows about me though, is that I am the child of two PhD holders.  It's probably not immediately apparent what being the child of two PhD holders has to do with defining infrastructure as code across your organisation.  Erm, for that I would say to you all that being the child of two PhD holders, and having read their PhDs, teaches you the value in repeatable experiments, and in being able to validate your findings in multiple scenarios.  Outside of work, I am an occasional author and kitchen alchemist - sometimes that ends really well, sometimes it doesn't.  I'm also a raging sportsball fan, and I am taking a break from the hockey garb which has been common recently, and we're going with New England Patriots football gear instead today.

PATRIOTS FAN IN AUDIENCE: [claps]

DAWN: So, back to that thing about being the child of two PhDs.  The reason why it is relevant for this talk is because, the- although what I'm talking about is infrastructure as code tools, this is predicated on a concept called Conway's law, which, as the name would suggest, was invented by a gentleman called Conway.  A paraphrase of what this is about is to say that 'Conway's law is- the maxim that an organisation will always design - tools, software, products, whatever - which reflect the organisation's structure'.  And that means that by first principles, if you want to design yourself a system, you have to start by designing the structures that are going to build it.  You have to design the people which are going to build it.  You have to design an architecture of teams; an architecture of reporting which will enable you to actually build what you want to build.  And as befits my parents and their PhDs, Conway's law has actually been validated in multiple academic settings by researchers who have gone and looked at big companies such as Microsoft.  And they found that generally this maxim holds true.

So why is it that org structure matters? This is signifi- or, my take on this, at least, is significantly less researched than the fact that it does, but the first thing that I would call out here is that if teams actually talk to each other, they're going to work much faster, and the work that they're going to produce is generally going to be a lot better.  When you have people sitting alone in silos developing things, there's often a lot of information in people's heads which is not cross-pollinating.  And if that information were cross-pollinating, it would potentially speed up the work that you were trying to do.  A colleague of mine at Innablr called Colin Liddle - really great guy - wrote a blog post for us a while back talking about the idea of platform teams.  Colin and I also worked together at a previous job, and both of us were, at various times, part of the platform team there.  And one takeaway that he called out in that blog post which I absolutely agree with is that the paradigm of the platform team, which is one which is- sort of becoming much more common now - it means that if you have people who are maintaining your baseline, you free up the dev teams to get work done.

If every team is managing their own Kubernetes cluster, and I know that Kubernetes is becoming a bit of a schtick here, but that means that 95% of their time is going to be taken up actually managing the infra to make sure that it's working.  Even if it is Kubernetes, if you can centralise that all in one place and have a group of specialists managing it, then all that the people who are deploying to it need to know is about what they need to do to deploy.  And those dedicated support people are inherently going to reduce blockers.  They are going to reduce lead times.  Because when you have a problem that's not in your domain, if you've got dedicated support people who can help you with it, you're not smashing your head repeatedly against a brick wall.  You can go to them, interact with them, and that will enable you to get things done quicker.  And ultimately this idea of, sort of, cross-functional working groups ends up being a bit fallacious a lot of the time, because - they're not consistent, and they're often arranged on an ad-hoc basis.  If you have a simple and appropriate team structure, which kind of matches the size and the scale of your organisation, in the end, what you're going to end up with is a simpler final product.  For large organisations, some degree of complexity is inherent to their structure, but if you can work out how to harness that complexity in the correct way, it will allow you to produce software which is ultimately much more simple.

So, this brings me to the question of how to architect a company - but, as those of you who've seen all of my talks would know, it's probably better described as how not to architect a company.  Because a lot of the companies that are around - even big companies, even companies like AWS - once upon a time were a bunch of people in a shed, or a bunch of people working for another company, who eventually got spun off into their own structure.  And if you do not think about solution architecture and design architecture for your organisation, what you end up doing is building complexity in on the fly.  You scale, but you don't necessarily scale in a way that's going to keep you running at the same velocity when you're ten times or a hundred times bigger.  And what a lot of that complexity tends to come in the form of i- are siloed teams that don't have a central support structure.  You need to scale, you spin up another team to run it.  But then you've got that problem of a whole bunch of redundant work is being done.  There's information in multiple people's heads.  Everyone has various different pieces of the jigsaw, but you can't put together the puzzle until you get all of them together, so they have to go and find the bits themselves.

The other fallacy, which I think is slightly less common but I'm aware of a few examples of this in the wild, is when you get really deep team-based hierarchies.  So rather than one or two levels, you've got four or five.  You've got different levels of teams that are building complexity on top of each other.  And what will tend to happen there is you lose critical information in communication.  If you've got one people that are buildi- one group of people that are building the infrastructure, and then you've got another group of people that are building on top of that, and a third group that's building on top of that, and then a fourth group that's finally building your application, how does the information that the application team need from the people who are building that core infrastructure get through those layers of hierarchy?

